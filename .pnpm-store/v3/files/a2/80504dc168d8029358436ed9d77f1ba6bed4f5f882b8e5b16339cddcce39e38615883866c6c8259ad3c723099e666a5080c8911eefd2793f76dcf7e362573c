{"version":3,"file":"effector-vue.umd.js","sources":["../../src/vue/index.ts"],"sourcesContent":["import Vue, {VueConstructor, ComponentOptions} from 'vue'\nimport {createEvent, restore, is, combine, Store, withRegion, clearNode, forward, Unit} from 'effector'\n\nexport interface EffectorVue extends Vue {\n  $watchAsStore: typeof watchAsStore;\n  $store: typeof store;\n}\n\nexport const VueEffector = (\n  vue: VueConstructor<EffectorVue>,\n  options: Object,\n) => {\n  vue.mixin(effectorMixin)\n  /** @deprecated since v21.1.0 */\n  vue.prototype.$watchAsStore = watchAsStore\n  /** @deprecated since v21.1.0 */\n  vue.prototype.$store = store\n}\n\nconst effectorMixin: ComponentOptions<Vue> = {\n  beforeCreate() {\n    let shape = this.$options.effector;\n\n    if (typeof shape === \"function\") {\n      // @ts-ignore\n      shape = shape.call(this)\n    }\n    if (!shape) return;\n    if (!this.$options.computed) this.$options.computed = {}\n\n    let obj: { [key: string]: Unit<any> } = {}\n\n    // normalize effector field data\n    if (is.store(shape)) {\n      obj = { state: shape }\n    } else if (typeof shape === 'object') {\n      obj = { ...shape }\n    } else {\n      throw Error('property should be Store')\n    }\n\n    // @ts-ignore\n    this.__clear = createEvent();\n\n    // @ts-ignore\n    withRegion(this.__clear, () => {\n      const state: Record<string, Store<any>> = {};\n      let nextID = 0;\n\n      for(const key in obj) {\n        const v = obj[key];\n\n        if (is.store(v)) {\n          state[key] = v;\n        } else if (is.event(v) || is.effect(v)) {\n          state[key] = restore(v.map(() => ++nextID), null);\n        } else {\n          throw Error(`Effector property ${key} should be Store or Unit (will be transform to Store<number>)`);\n        }\n      }\n\n      const store = combine(state)\n      for(const key in store.defaultState) {\n        // @ts-ignore\n        Vue.util.defineReactive(this, key, store.defaultState[key])\n      }\n\n      store.watch(value => {\n        for (const key in value) {\n          // @ts-ignore\n          this[key] = value[key]\n        }\n      })\n\n      for (const key in state) {\n        const updated = createEvent();\n        forward({ from: updated, to: state[key] });\n\n        // @ts-ignore\n        this.$options.computed[key] = {\n          // @ts-ignore\n          get: () => this[key],\n          set: updated\n        };\n      }\n    })\n  },\n\n  beforeDestroy() {\n    // @ts-ignore\n    if (this.__clear) {\n      // @ts-ignore\n      clearNode(this.__clear);\n    }\n  }\n}\n\nexport function createComponent<S>(options: any, store?: S) {\n  return Vue.extend(\n    Object.assign(\n      {},\n      options,\n      store && {\n        effector: () => store\n      },\n    ),\n  )\n}\n\nfunction watchAsStore(\n  this: EffectorVue,\n  expOrFn: string | Function,\n  options: {\n    immediate?: boolean\n  } = {\n    immediate: true,\n  },\n): Store<{oldValue: any; newValue: any}> {\n  console.error('$watchAsStore is deprecated')\n  \n  const update = createEvent<{oldValue: any; newValue: any}>()\n  const store = restore(update, {} as any)\n  const watch = () => {\n    this.$watch(\n      //@ts-ignore\n      expOrFn,\n      //@ts-ignore\n      (newValue, oldValue) => {\n        update({oldValue, newValue})\n      },\n      options,\n    )\n  }\n  //@ts-ignore\n  if (this._data) {\n    watch()\n  } else {\n    this.$once('hook:created', watch)\n  }\n\n  return store\n}\n\nfunction store<State>(\n  this: EffectorVue,\n  expOrFn: string | Function,\n): Store<State> {\n  console.error('$store is deprecated')\n\n  return this.$watchAsStore(expOrFn).map(({newValue}) => newValue)\n}\n"],"names":["watchAsStore","expOrFn","options","immediate","console","error","update","createEvent","store","restore","watch","$watch","newValue","oldValue","this","_data","$once","$watchAsStore","map","effectorMixin","beforeCreate","shape","$options","effector","call","computed","obj","is","state","Error","__clear","withRegion","nextID","key","v","event","effect","combine","defaultState","Vue","util","defineReactive","value","updated","forward","from","to","get","set","beforeDestroy","clearNode","vue","mixin","prototype","$store","extend","Object","assign"],"mappings":"yXA6GA,SAASA,EAEPC,EACAC,EAEI,CACFC,UAAW,IAGbC,QAAQC,MAAM,mCAERC,EAASC,uBACTC,EAAQC,iBAAQH,EAAQ,IACxBI,EAAQ,UACPC,OAEHV,IAECW,EAAUC,KACTP,EAAO,CAACO,SAAAA,EAAUD,SAAAA,MAEpBV,WAIAY,KAAKC,MACPL,SAEKM,MAAM,eAAgBN,GAGtBF,EAGT,SAASA,EAEPP,UAEAG,QAAQC,MAAM,wBAEPS,KAAKG,cAAchB,GAASiB,KAAI,EAAEN,SAAAA,KAAcA,eAlIzD,MAAMO,EAAuC,CAC3CC,mBACMC,EAAQP,KAAKQ,SAASC,YAEL,mBAAVF,IAETA,EAAQA,EAAMG,KAAKV,QAEhBO,EAAO,OACPP,KAAKQ,SAASG,WAAUX,KAAKQ,SAASG,SAAW,QAElDC,EAAoC,MAGpCC,YAAGnB,MAAMa,GACXK,EAAM,CAAEE,MAAOP,OACV,CAAA,GAAqB,iBAAVA,QAGVQ,MAAM,4BAFZH,EAAM,IAAKL,QAMRS,QAAUvB,uBAGfwB,oBAAWjB,KAAKgB,SAAS,SACjBF,EAAoC,GACtCI,EAAS,MAET,IAAMC,KAAOP,EAAK,KACdQ,EAAIR,EAAIO,MAEVN,YAAGnB,MAAM0B,GACXN,EAAMK,GAAOC,MACR,CAAA,IAAIP,YAAGQ,MAAMD,KAAMP,YAAGS,OAAOF,SAG5BL,MAAO,qBAAoBI,kEAFjCL,EAAMK,GAAOxB,iBAAQyB,EAAEhB,KAAI,MAAQc,IAAS,WAM1CxB,EAAQ6B,iBAAQT,OAClB,IAAMK,KAAOzB,EAAM8B,aAErBC,UAAIC,KAAKC,eAAe3B,KAAMmB,EAAKzB,EAAM8B,aAAaL,IAGxDzB,EAAME,OAAMgC,QACL,IAAMT,KAAOS,OAEXT,GAAOS,EAAMT,UAIjB,IAAMA,KAAOL,EAAO,KACjBe,EAAUpC,uBAChBqC,iBAAQ,CAAEC,KAAMF,EAASG,GAAIlB,EAAMK,UAG9BX,SAASG,SAASQ,GAAO,CAE5Bc,IAAK,IAAMjC,KAAKmB,GAChBe,IAAKL,QAMbM,gBAEMnC,KAAKgB,SAEPoB,mBAAUpC,KAAKgB,yBAnFnBqB,IAGAA,EAAIC,MAAMjC,GAEVgC,EAAIE,UAAUpC,cAAgBjB,EAE9BmD,EAAIE,UAAUC,OAAS9C,qBAiFlB,CAA4BN,EAAcM,IACxC+B,UAAIgB,OACTC,OAAOC,OACL,GACAvD,EACAM,GAAS,CACPe,SAAU,IAAMf"}