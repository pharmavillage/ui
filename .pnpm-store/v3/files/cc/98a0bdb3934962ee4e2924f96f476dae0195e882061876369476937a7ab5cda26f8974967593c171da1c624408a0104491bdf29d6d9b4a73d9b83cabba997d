{"version":3,"file":"composition.cjs.js","sources":["effector-vue/lib/create-watch.ts","effector-vue/lib/state-reader.ts","effector-vue/lib/get-scope.ts","effector-vue/lib/unwrapProxy.ts","effector-vue/lib/deepCopy.ts","effector-vue/useVModel.ts","effector-vue/../effector/config.ts","effector-vue/../effector/is.ts","effector-vue/../effector/throw.ts","effector-vue/createGate.ts","effector-vue/lib/throw.ts","effector-vue/useStoreMap.ts","effector-vue/../effector/collection.ts","effector-vue/useStore.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {Store, clearNode, step, createNode, Scope, Node} from \"effector\"\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n) {\n  let seq = [step.run({fn: (value) => fn(value)})]\n  if (scope) {\n    let node = createNode({node: seq})\n    let id = (store as any).graphite.id\n    let scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    let links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      let idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    let node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","import {Scope, Store} from \"effector\"\n\nexport function stateReader<T>(store: Store<T>, scope?: Scope) {\n  return scope ? scope.getState(store) : store.getState()\n}\n","import {Scope} from \"effector\"\nimport {getCurrentInstance, inject} from \"vue-next\"\n\nexport function getScope() {\n  let scope: Scope | undefined\n  let ctx = getCurrentInstance()\n  let scopeName: string | undefined = ctx?.appContext.config.globalProperties.scopeName\n\n  if (scopeName) {\n    scope = inject(scopeName)\n  }\n\n  return {\n    scopeName,\n    scope,\n  }\n}\n","import {isReactive, toRaw, unref} from 'vue-next'\n\nexport function unwrapProxy<T>(payload: T) {\n  const data = unref(payload)\n  const raw = isReactive(data) ? toRaw(data) : data\n  return raw\n}\n","// @ts-nocheck\nfunction find(list, f) {\n  return list.filter(f)[0]\n}\n\nexport function deepCopy<T>(obj, cache = []): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const hit = find(cache, c => c.original === obj)\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ? [] : {}\n  cache.push({\n    original: obj,\n    copy,\n  })\n\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n","import {Store, is, createStore} from \"effector\"\nimport {onUnmounted, reactive, Ref, ref, watch} from \"vue-next\"\n\nimport {unwrapProxy} from \"./lib/unwrapProxy\"\nimport {deepCopy} from \"./lib/deepCopy\"\nimport {stateReader} from \"./lib/state-reader\"\nimport {createWatch} from \"./lib/create-watch\"\nimport {getScope} from \"./lib/get-scope\"\nimport { UseVModel } from \"effector-vue/composition\"\n\nfunction createVModel<T>(store: Store<T>, key?: string, shape?: Record<string, unknown>) {\n  if (!is.store(store)) throw Error(\"expect useVModel argument to be a store\")\n\n  let {scope} = getScope()\n\n  let _ = ref(\n    deepCopy(stateReader(store, scope))\n  )\n\n  let isSelfUpdate = false\n  let fromEvent = false\n\n  let stop = createWatch(\n    store,\n    (payload) => {\n      if (isSelfUpdate) {\n        return\n      }\n\n      fromEvent = true\n      _.value = ref(deepCopy(payload)).value\n    },\n    scope\n  )\n\n  onUnmounted(() => {\n    stop()\n  })\n\n  const watchFn = () => {\n    if (key && shape) {\n      return shape[key]\n    }\n    return _.value\n  }\n\n  watch(\n    watchFn,\n    (value) => {\n      isSelfUpdate = true\n\n      if (!fromEvent) {\n        let raw = ref(unwrapProxy(value)).value\n        // @ts-ignore\n        store.setState(deepCopy(raw))\n      }\n\n      fromEvent = false\n      isSelfUpdate = false\n    },\n    {deep: true, immediate: false},\n  )\n\n  return _ as Ref<T>\n}\n\nfunction isStore<T,>(arg: Store<T> | Record<string, unknown>): arg is Store<T> {\n  return is.store(arg)\n}\n\n// @ts-expect-error\nexport const useVModel: UseVModel = <T, K extends string = keyof Store<unknown>>(vm: Store<T> | Record<K, Store<T>>) => {\n  if (isStore(vm)) {\n    return createVModel(vm)\n  }\n\n  const _ = reactive({})\n\n  const shape = Object.fromEntries(\n    Object.entries<Store<T>>(vm).map(([key, value]) => [key, createVModel(value, key, _)])\n  )\n\n  for (const key in shape) {\n    // @ts-ignore\n    _[key] = shape[key]\n  }\n\n  return _\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {\n  computed,\n  ComputedRef,\n  onMounted,\n  onUnmounted,\n  watch,\n  WatchStopHandle,\n} from 'vue-next'\nimport {createApi, launch, createStore, createEvent, sample} from 'effector'\nimport {Gate, GateConfig} from './composition.h'\nimport {deepCopy} from './lib/deepCopy'\nimport {unwrapProxy} from './lib/unwrapProxy'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function useGate<Props>(GateComponent: Gate<Props>, cb?: () => Props) {\n  let unwatch: WatchStopHandle\n  let _: ComputedRef<Props>\n\n  if (cb) {\n    _ = computed(cb)\n\n    unwatch = watch(\n      _,\n      value => {\n        const raw = unwrapProxy(value)\n        GateComponent.set(deepCopy(raw))\n      },\n      {\n        deep: true,\n        immediate: true,\n      },\n    )\n  }\n\n  onMounted(() => {\n    if (typeof _ !== \"undefined\") {\n      const raw = unwrapProxy(_.value)\n      GateComponent.open(deepCopy(raw))\n    } else {\n      GateComponent.open()\n    }\n  })\n\n  onUnmounted(() => {\n    if (typeof _ !== \"undefined\") {\n      const raw = unwrapProxy(_.value)\n      GateComponent.close(deepCopy(raw))\n    } else {\n      GateComponent.close()\n    }\n\n    if (unwatch) {\n      unwatch()\n    }\n  })\n}\n\nexport function isStructuredConfig(args: unknown) {\n  return isObject(args) && (args.and || args.or)\n}\n\nexport function createGate<Props>(...args: [GateConfig<Props>]): Gate<Props> {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n\n  const [[rawConfig], metadata] = processArgsToConfig(universalConfig)\n  const config = flattenConfig({\n    or: metadata,\n    and: rawConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config?.name || 'gate'\n  const domain = rawConfig?.domain\n\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<Props>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<Props>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<Props>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n  const state = createStore<Props>(rawConfig?.defaultState ?? null, {\n    name: `${fullName}.state`,\n    sid: config?.sid,\n  })\n\n  state.on(set, (_, state) => state)\n  status.on(open, () => Boolean(true)).on(close, () => Boolean(false))\n\n  function GateComponent(props: Props) {\n    useGate(GateComponent as any, () => props)\n  }\n\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n\n  sample({ clock: open, target: set })\n\n  state.reset(close)\n\n  if (rawConfig?.domain) {\n    const {hooks} = rawConfig.domain\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n\n  // @ts-ignore\n  return GateComponent\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import { createWatch, is, Scope, Store } from \"effector\";\nimport { computed, onUnmounted, shallowReactive, shallowRef } from \"vue-next\";\nimport { getScope } from \"./lib/get-scope\";\nimport { stateReader } from \"./lib/state-reader\";\nimport { throwError } from \"./lib/throw\";\n\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\n\nexport function useStoreMap<State, Result, Keys = unknown>(\n  config: {\n    store: Store<State>;\n    keys?: () => Keys;\n    fn: (state: State, keys: Keys) => Result;\n    updateFilter?: (update: Result, current: Result) => boolean;\n    defaultValue?: Result;\n  },\n  scope?: Scope\n) {\n  if (!is.store(config.store)) throwError('useStoreMap expects a store')\n  if (config.keys !== undefined && typeof config.keys !== 'function') throwError('useStoreMap expects keys as a function')\n  if (typeof config.fn !== 'function') throwError('useStoreMap expects fn as a function')\n\n\n  let _scope = scope || getScope().scope\n  let keys = config.keys ? computed(config.keys) : computed(() => undefined as Keys)\n  let updateFilter = config.updateFilter || basicUpdateFilter;\n\n  let state = stateReader(config.store, _scope)\n  let isShape = typeof state === \"object\" && Array.isArray(state) === false\n\n  let _ = isShape ? shallowReactive(state as any) : shallowRef(state)\n\n  let stop = createWatch({\n    unit: config.store,\n    fn: (value) => {\n      if (isShape) {\n        for (let key in value) {\n          if (updateFilter(value[key] as Result, _[key])) {\n            _[key] = value[key]\n          }\n        }\n      } else {\n        if (value !== undefined && updateFilter(value as unknown as Result, _.value)) {\n          _.value = value\n        }\n      }\n    },\n    scope: _scope\n  })\n\n  onUnmounted(() => {\n    stop()\n  })\n\n  return computed(() => {\n    let result = config.fn(isShape ? _ : _.value, keys.value)\n    return result !== undefined ? result : config.defaultValue\n  })\n}\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {is, Store} from \"effector\"\nimport {onUnmounted, readonly, shallowRef} from \"vue-next\"\n\nimport {createWatch} from \"./lib/create-watch\"\nimport {stateReader} from \"./lib/state-reader\"\nimport {getScope} from \"./lib/get-scope\"\nimport {throwError} from \"./lib/throw\"\n\nexport function useStore<T>(store: Store<T>) {\n  if (!is.store(store)) throwError(\"expect useStore argument to be a store\")\n  let {scope} = getScope()\n\n  let state = stateReader(store, scope)\n  let _ = shallowRef(state)\n\n  let stop = createWatch(\n    store,\n    (value) => {\n      _.value = shallowRef(value).value\n    },\n    scope\n  )\n\n  onUnmounted(() => {\n    stop()\n  })\n\n  return readonly(_)\n}\n"],"names":["createWatch","store","fn","scope","seq","step","run","value","node","createNode","id","graphite","scopeLinks","additionalLinks","links","push","idx","indexOf","splice","clearNode","parent","family","owners","stateReader","getState","getScope","ctx","getCurrentInstance","scopeName","appContext","config","globalProperties","inject","unwrapProxy","payload","data","unref","isReactive","toRaw","deepCopy","obj","cache","hit","filter","c","original","copy","Array","isArray","Object","keys","forEach","key","createVModel","shape","is","Error","_","ref","isSelfUpdate","fromEvent","stop","onUnmounted","watch","raw","setState","deep","immediate","processArgsToConfig","args","singleArgument","rawConfig","condition","assert","isObject","isFunction","metadata","or","childConfig","and","unwrappedNestedValue","nested","useGate","GateComponent","cb","unwatch","computed","set","onMounted","open","close","throwError","message","basicUpdateFilter","upd","oldValue","flattenConfig","part","field","undefined","isVoid","forIn","props","universalConfig","isStructuredConfig","domain","fullName","compositeName","name","createEvent","sid","status","createStore","Boolean","serialize","state","defaultState","on","sample","clock","target","reset","hooks","launch","event","params","shallowRef","readonly","_scope","updateFilter","isShape","shallowReactive","unit","result","defaultValue","vm","reactive","fromEntries","entries","map"],"mappings":"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"}