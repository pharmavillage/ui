{"version":3,"file":"compat.js","sources":["effector-vue/index.ts"],"sourcesContent":["import Vue, {VueConstructor, ComponentOptions} from 'vue'\nimport {createEvent, restore, is, combine, Store, withRegion, clearNode, forward, Unit} from 'effector'\n\nexport interface EffectorVue extends Vue {\n  $watchAsStore: typeof watchAsStore;\n  $store: typeof store;\n}\n\nexport const VueEffector = (\n  vue: VueConstructor<EffectorVue>,\n  options: Object,\n) => {\n  vue.mixin(effectorMixin)\n  /** @deprecated since v21.1.0 */\n  vue.prototype.$watchAsStore = watchAsStore\n  /** @deprecated since v21.1.0 */\n  vue.prototype.$store = store\n}\n\nconst effectorMixin: ComponentOptions<Vue> = {\n  beforeCreate() {\n    let shape = this.$options.effector;\n\n    if (typeof shape === \"function\") {\n      // @ts-ignore\n      shape = shape.call(this)\n    }\n    if (!shape) return;\n    if (!this.$options.computed) this.$options.computed = {}\n\n    let obj: { [key: string]: Unit<any> } = {}\n\n    // normalize effector field data\n    if (is.store(shape)) {\n      obj = { state: shape }\n    } else if (typeof shape === 'object') {\n      obj = { ...shape }\n    } else {\n      throw Error('property should be Store')\n    }\n\n    // @ts-ignore\n    this.__clear = createEvent();\n\n    // @ts-ignore\n    withRegion(this.__clear, () => {\n      const state: Record<string, Store<any>> = {};\n      let nextID = 0;\n\n      for(const key in obj) {\n        const v = obj[key];\n\n        if (is.store(v)) {\n          state[key] = v;\n        } else if (is.event(v) || is.effect(v)) {\n          state[key] = restore(v.map(() => ++nextID), null);\n        } else {\n          throw Error(`Effector property ${key} should be Store or Unit (will be transform to Store<number>)`);\n        }\n      }\n\n      const store = combine(state)\n      for(const key in store.defaultState) {\n        // @ts-ignore\n        Vue.util.defineReactive(this, key, store.defaultState[key])\n      }\n\n      store.watch(value => {\n        for (const key in value) {\n          // @ts-ignore\n          this[key] = value[key]\n        }\n      })\n\n      for (const key in state) {\n        const updated = createEvent();\n        forward({ from: updated, to: state[key] });\n\n        // @ts-ignore\n        this.$options.computed[key] = {\n          // @ts-ignore\n          get: () => this[key],\n          set: updated\n        };\n      }\n    })\n  },\n\n  beforeDestroy() {\n    // @ts-ignore\n    if (this.__clear) {\n      // @ts-ignore\n      clearNode(this.__clear);\n    }\n  }\n}\n\nexport function createComponent<S>(options: any, store?: S) {\n  return Vue.extend(\n    Object.assign(\n      {},\n      options,\n      store && {\n        effector: () => store\n      },\n    ),\n  )\n}\n\nfunction watchAsStore(\n  this: EffectorVue,\n  expOrFn: string | Function,\n  options: {\n    immediate?: boolean\n  } = {\n    immediate: true,\n  },\n): Store<{oldValue: any; newValue: any}> {\n  console.error('$watchAsStore is deprecated')\n  \n  const update = createEvent<{oldValue: any; newValue: any}>()\n  const store = restore(update, {} as any)\n  const watch = () => {\n    this.$watch(\n      //@ts-ignore\n      expOrFn,\n      //@ts-ignore\n      (newValue, oldValue) => {\n        update({oldValue, newValue})\n      },\n      options,\n    )\n  }\n  //@ts-ignore\n  if (this._data) {\n    watch()\n  } else {\n    this.$once('hook:created', watch)\n  }\n\n  return store\n}\n\nfunction store<State>(\n  this: EffectorVue,\n  expOrFn: string | Function,\n): Store<State> {\n  console.error('$store is deprecated')\n\n  return this.$watchAsStore(expOrFn).map(({newValue}) => newValue)\n}\n"],"names":["watchAsStore","expOrFn","options","immediate","console","error","update","createEvent","store","restore","watch","_this2","$watch","newValue","oldValue","this","_data","$once","$watchAsStore","map","effectorMixin","beforeCreate","shape","$options","effector","call","computed","obj","is","state","Error","__clear","withRegion","nextID","key","v","event","effect","combine","defaultState","Vue","util","defineReactive","_this","value","updated","forward","from","to","get","set","beforeDestroy","clearNode","vue","mixin","prototype","$store","extend","Object","assign"],"mappings":"mFA6GA,SAASA,EAEPC,EACAC,uBAAAA,IAAAA,EAEI,CACFC,UAAW,IAGbC,QAAQC,MAAM,mCAERC,EAASC,gBACTC,EAAQC,UAAQH,EAAQ,IACxBI,EAAQ,WACZC,EAAKC,OAEHX,YAECY,EAAUC,GACTR,EAAO,CAACQ,SAAAA,EAAUD,SAAAA,MAEpBX,WAIAa,KAAKC,MACPN,SAEKO,MAAM,eAAgBP,GAGtBF,EAGT,SAASA,EAEPP,UAEAG,QAAQC,MAAM,wBAEPU,KAAKG,cAAcjB,GAASkB,KAAI,qBAAEN,2HAlIrCO,EAAuC,CAC3CC,mCACMC,EAAQP,KAAKQ,SAASC,YAEL,mBAAVF,IAETA,EAAQA,EAAMG,KAAKV,OAEhBO,GACAP,KAAKQ,SAASG,WAAUX,KAAKQ,SAASG,SAAW,QAElDC,EAAoC,MAGpCC,KAAGpB,MAAMc,GACXK,EAAM,CAAEE,MAAOP,OACV,CAAA,GAAqB,iBAAVA,QAGVQ,MAAM,4BAFZH,mBAAWL,QAMRS,QAAUxB,gBAGfyB,aAAWjB,KAAKgB,SAAS,eACjBF,EAAoC,GACtCI,EAAS,MAET,IAAMC,KAAOP,EAAK,KACdQ,EAAIR,EAAIO,MAEVN,KAAGpB,MAAM2B,GACXN,EAAMK,GAAOC,MACR,CAAA,IAAIP,KAAGQ,MAAMD,KAAMP,KAAGS,OAAOF,SAG5BL,2BAA2BI,mEAFjCL,EAAMK,GAAOzB,UAAQ0B,EAAEhB,KAAI,mBAAQc,KAAS,WAM1CzB,EAAQ8B,UAAQT,OAClB,IAAMK,KAAO1B,EAAM+B,aAErBC,EAAIC,KAAKC,eAAeC,EAAMT,EAAK1B,EAAM+B,aAAaL,IAGxD1B,EAAME,OAAM,SAAAkC,OACL,IAAMV,KAAOU,EAEhBD,EAAKT,GAAOU,EAAMV,qBAIXA,OACHW,EAAUtC,gBAChBuC,UAAQ,CAAEC,KAAMF,EAASG,GAAInB,EAAMK,KAGnCS,EAAKpB,SAASG,SAASQ,GAAO,CAE5Be,IAAK,kBAAMN,EAAKT,IAChBgB,IAAKL,QARJ,IAAMX,KAAOL,IAAPK,QAcfiB,yBAEMpC,KAAKgB,SAEPqB,YAAUrC,KAAKgB,+BApFM,SACzBsB,GAGAA,EAAIC,MAAMlC,GAEViC,EAAIE,UAAUrC,cAAgBlB,EAE9BqD,EAAIE,UAAUC,OAAShD,2BAiFlB,SAA4BN,EAAcM,UACxCgC,EAAIiB,OACTC,OAAOC,OACL,GACAzD,EACAM,GAAS,CACPgB,SAAU,kBAAMhB"}