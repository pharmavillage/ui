((e,t)=>{'object'==typeof exports&&'undefined'!=typeof module?t(exports,require('vue'),require('effector')):'function'==typeof define&&define.amd?define(['exports','vue','effector'],t):t((e='undefined'!=typeof globalThis?globalThis:e||self).effectorVue={},e.Vue,e.effector)})(this,(function(e,t,effector){function o(e){return e&&'object'==typeof e&&'default'in e?e:{default:e}}function r(e,t={immediate:1}){console.error('$watchAsStore is deprecated');let o=effector.createEvent(),r=effector.restore(o,{}),i=()=>{this.$watch(e,((e,t)=>{o({oldValue:t,newValue:e})}),t)};return this._data?i():this.$once('hook:created',i),r}function i(e){return console.error('$store is deprecated'),this.$watchAsStore(e).map((({newValue:e})=>e))}var f=o(t);const s={beforeCreate(){let e=this.$options.effector;if("function"==typeof e&&(e=e.call(this)),!e)return;this.$options.computed||(this.$options.computed={});let t={};if(effector.is.store(e))t={state:e};else{if('object'!=typeof e)throw Error('property should be Store');t={...e}}this.__clear=effector.createEvent(),effector.withRegion(this.__clear,(()=>{let e={},o=0;for(let r in t){let i=t[r];if(effector.is.store(i))e[r]=i;else{if(!effector.is.event(i)&&!effector.is.effect(i))throw Error(`Effector property ${r} should be Store or Unit (will be transform to Store<number>)`);e[r]=effector.restore(i.map((()=>++o)),null)}}let r=effector.combine(e);for(let e in r.defaultState)f.default.util.defineReactive(this,e,r.defaultState[e]);r.watch((e=>{for(let t in e)this[t]=e[t]}));for(let t in e){let o=effector.createEvent();effector.forward({from:o,to:e[t]}),this.$options.computed[t]={get:()=>this[t],set:o}}}))},beforeDestroy(){this.__clear&&effector.clearNode(this.__clear)}};e.VueEffector=e=>{e.mixin(s),e.prototype.$watchAsStore=r,e.prototype.$store=i},e.createComponent=(e,t)=>f.default.extend(Object.assign({},e,t&&{effector:()=>t})),Object.defineProperty(e,'__esModule',{value:1})}));
//# sourceMappingURL=effector-vue.umd.js.map
