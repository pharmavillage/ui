{"version":3,"file":"composition.mjs","sources":["effector-vue/lib/create-watch.ts","effector-vue/lib/state-reader.ts","effector-vue/lib/get-scope.ts","effector-vue/useStore.ts","effector-vue/lib/unwrapProxy.ts","effector-vue/lib/deepCopy.ts","effector-vue/useVModel.ts","effector-vue/useStoreMap.ts","effector-vue/../effector/config.ts","effector-vue/../effector/is.ts","effector-vue/../effector/throw.ts","effector-vue/createGate.ts","effector-vue/lib/throw.ts","effector-vue/../effector/collection.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {Store, clearNode, step, createNode, Scope, Node} from \"effector\"\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n) {\n  let seq = [step.run({fn: (value) => fn(value)})]\n  if (scope) {\n    let node = createNode({node: seq})\n    let id = (store as any).graphite.id\n    let scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    let links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      let idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    let node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","import {Scope, Store} from \"effector\"\n\nexport function stateReader<T>(store: Store<T>, scope?: Scope) {\n  return scope ? scope.getState(store) : store.getState()\n}\n","import {Scope} from \"effector\"\nimport {getCurrentInstance, inject} from \"vue-next\"\n\nexport function getScope() {\n  let scope: Scope | undefined\n  let ctx = getCurrentInstance()\n  let scopeName: string | undefined = ctx?.appContext.config.globalProperties.scopeName\n\n  if (scopeName) {\n    scope = inject(scopeName)\n  }\n\n  return {\n    scopeName,\n    scope,\n  }\n}\n","import {is, Store} from \"effector\"\nimport {onUnmounted, readonly, shallowRef} from \"vue-next\"\n\nimport {createWatch} from \"./lib/create-watch\"\nimport {stateReader} from \"./lib/state-reader\"\nimport {getScope} from \"./lib/get-scope\"\nimport {throwError} from \"./lib/throw\"\n\nexport function useStore<T>(store: Store<T>) {\n  if (!is.store(store)) throwError(\"expect useStore argument to be a store\")\n  let {scope} = getScope()\n\n  let state = stateReader(store, scope)\n  let _ = shallowRef(state)\n\n  let stop = createWatch(\n    store,\n    (value) => {\n      _.value = shallowRef(value).value\n    },\n    scope\n  )\n\n  onUnmounted(() => {\n    stop()\n  })\n\n  return readonly(_)\n}\n","import {isReactive, toRaw, unref} from 'vue-next'\n\nexport function unwrapProxy<T>(payload: T) {\n  const data = unref(payload)\n  const raw = isReactive(data) ? toRaw(data) : data\n  return raw\n}\n","// @ts-nocheck\nfunction find(list, f) {\n  return list.filter(f)[0]\n}\n\nexport function deepCopy<T>(obj, cache = []): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const hit = find(cache, c => c.original === obj)\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ? [] : {}\n  cache.push({\n    original: obj,\n    copy,\n  })\n\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n","import {Store, is, createStore} from \"effector\"\nimport {onUnmounted, reactive, Ref, ref, watch} from \"vue-next\"\n\nimport {unwrapProxy} from \"./lib/unwrapProxy\"\nimport {deepCopy} from \"./lib/deepCopy\"\nimport {stateReader} from \"./lib/state-reader\"\nimport {createWatch} from \"./lib/create-watch\"\nimport {getScope} from \"./lib/get-scope\"\nimport { UseVModel } from \"effector-vue/composition\"\n\nfunction createVModel<T>(store: Store<T>, key?: string, shape?: Record<string, unknown>) {\n  if (!is.store(store)) throw Error(\"expect useVModel argument to be a store\")\n\n  let {scope} = getScope()\n\n  let _ = ref(\n    deepCopy(stateReader(store, scope))\n  )\n\n  let isSelfUpdate = false\n  let fromEvent = false\n\n  let stop = createWatch(\n    store,\n    (payload) => {\n      if (isSelfUpdate) {\n        return\n      }\n\n      fromEvent = true\n      _.value = ref(deepCopy(payload)).value\n    },\n    scope\n  )\n\n  onUnmounted(() => {\n    stop()\n  })\n\n  const watchFn = () => {\n    if (key && shape) {\n      return shape[key]\n    }\n    return _.value\n  }\n\n  watch(\n    watchFn,\n    (value) => {\n      isSelfUpdate = true\n\n      if (!fromEvent) {\n        let raw = ref(unwrapProxy(value)).value\n        // @ts-ignore\n        store.setState(deepCopy(raw))\n      }\n\n      fromEvent = false\n      isSelfUpdate = false\n    },\n    {deep: true, immediate: false},\n  )\n\n  return _ as Ref<T>\n}\n\nfunction isStore<T,>(arg: Store<T> | Record<string, unknown>): arg is Store<T> {\n  return is.store(arg)\n}\n\n// @ts-expect-error\nexport const useVModel: UseVModel = <T, K extends string = keyof Store<unknown>>(vm: Store<T> | Record<K, Store<T>>) => {\n  if (isStore(vm)) {\n    return createVModel(vm)\n  }\n\n  const _ = reactive({})\n\n  const shape = Object.fromEntries(\n    Object.entries<Store<T>>(vm).map(([key, value]) => [key, createVModel(value, key, _)])\n  )\n\n  for (const key in shape) {\n    // @ts-ignore\n    _[key] = shape[key]\n  }\n\n  return _\n}\n","import { createWatch, is, Scope, Store } from \"effector\";\nimport { computed, onUnmounted, shallowReactive, shallowRef } from \"vue-next\";\nimport { getScope } from \"./lib/get-scope\";\nimport { stateReader } from \"./lib/state-reader\";\nimport { throwError } from \"./lib/throw\";\n\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\n\nexport function useStoreMap<State, Result, Keys = unknown>(\n  config: {\n    store: Store<State>;\n    keys?: () => Keys;\n    fn: (state: State, keys: Keys) => Result;\n    updateFilter?: (update: Result, current: Result) => boolean;\n    defaultValue?: Result;\n  },\n  scope?: Scope\n) {\n  if (!is.store(config.store)) throwError('useStoreMap expects a store')\n  if (config.keys !== undefined && typeof config.keys !== 'function') throwError('useStoreMap expects keys as a function')\n  if (typeof config.fn !== 'function') throwError('useStoreMap expects fn as a function')\n\n\n  let _scope = scope || getScope().scope\n  let keys = config.keys ? computed(config.keys) : computed(() => undefined as Keys)\n  let updateFilter = config.updateFilter || basicUpdateFilter;\n\n  let state = stateReader(config.store, _scope)\n  let isShape = typeof state === \"object\" && Array.isArray(state) === false\n\n  let _ = isShape ? shallowReactive(state as any) : shallowRef(state)\n\n  let stop = createWatch({\n    unit: config.store,\n    fn: (value) => {\n      if (isShape) {\n        for (let key in value) {\n          if (updateFilter(value[key] as Result, _[key])) {\n            _[key] = value[key]\n          }\n        }\n      } else {\n        if (value !== undefined && updateFilter(value as unknown as Result, _.value)) {\n          _.value = value\n        }\n      }\n    },\n    scope: _scope\n  })\n\n  onUnmounted(() => {\n    stop()\n  })\n\n  return computed(() => {\n    let result = config.fn(isShape ? _ : _.value, keys.value)\n    return result !== undefined ? result : config.defaultValue\n  })\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {\n  computed,\n  ComputedRef,\n  onMounted,\n  onUnmounted,\n  watch,\n  WatchStopHandle,\n} from 'vue-next'\nimport {createApi, launch, createStore, createEvent, sample} from 'effector'\nimport {Gate, GateConfig} from './composition.h'\nimport {deepCopy} from './lib/deepCopy'\nimport {unwrapProxy} from './lib/unwrapProxy'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function useGate<Props>(GateComponent: Gate<Props>, cb?: () => Props) {\n  let unwatch: WatchStopHandle\n  let _: ComputedRef<Props>\n\n  if (cb) {\n    _ = computed(cb)\n\n    unwatch = watch(\n      _,\n      value => {\n        const raw = unwrapProxy(value)\n        GateComponent.set(deepCopy(raw))\n      },\n      {\n        deep: true,\n        immediate: true,\n      },\n    )\n  }\n\n  onMounted(() => {\n    if (typeof _ !== \"undefined\") {\n      const raw = unwrapProxy(_.value)\n      GateComponent.open(deepCopy(raw))\n    } else {\n      GateComponent.open()\n    }\n  })\n\n  onUnmounted(() => {\n    if (typeof _ !== \"undefined\") {\n      const raw = unwrapProxy(_.value)\n      GateComponent.close(deepCopy(raw))\n    } else {\n      GateComponent.close()\n    }\n\n    if (unwatch) {\n      unwatch()\n    }\n  })\n}\n\nexport function isStructuredConfig(args: unknown) {\n  return isObject(args) && (args.and || args.or)\n}\n\nexport function createGate<Props>(...args: [GateConfig<Props>]): Gate<Props> {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n\n  const [[rawConfig], metadata] = processArgsToConfig(universalConfig)\n  const config = flattenConfig({\n    or: metadata,\n    and: rawConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config?.name || 'gate'\n  const domain = rawConfig?.domain\n\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<Props>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<Props>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<Props>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n  const state = createStore<Props>(rawConfig?.defaultState ?? null, {\n    name: `${fullName}.state`,\n    sid: config?.sid,\n  })\n\n  state.on(set, (_, state) => state)\n  status.on(open, () => Boolean(true)).on(close, () => Boolean(false))\n\n  function GateComponent(props: Props) {\n    useGate(GateComponent as any, () => props)\n  }\n\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n\n  sample({ clock: open, target: set })\n\n  state.reset(close)\n\n  if (rawConfig?.domain) {\n    const {hooks} = rawConfig.domain\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n\n  // @ts-ignore\n  return GateComponent\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n"],"names":["createWatch","store","fn","scope","seq","step","run","value","node","createNode","id","graphite","scopeLinks","additionalLinks","links","push","idx","indexOf","splice","clearNode","parent","family","owners","stateReader","getState","getScope","ctx","getCurrentInstance","scopeName","appContext","config","globalProperties","inject","useStore","is","throwError","state","_","shallowRef","stop","onUnmounted","readonly","unwrapProxy","payload","data","unref","isReactive","toRaw","deepCopy","obj","cache","hit","filter","c","original","copy","Array","isArray","Object","keys","forEach","key","createVModel","shape","Error","ref","isSelfUpdate","fromEvent","watch","raw","setState","deep","immediate","useStoreMap","undefined","_scope","computed","updateFilter","basicUpdateFilter","isShape","shallowReactive","unit","result","defaultValue","processArgsToConfig","args","singleArgument","rawConfig","condition","assert","isObject","isFunction","metadata","or","childConfig","and","unwrappedNestedValue","nested","useGate","GateComponent","cb","unwatch","set","onMounted","open","close","createGate","props","universalConfig","isStructuredConfig","flattenConfig","domain","fullName","compositeName","name","createEvent","sid","status","createStore","Boolean","serialize","defaultState","on","sample","clock","target","reset","hooks","launch","event","params","message","useVModel","vm","reactive","fromEntries","entries","map","upd","oldValue","part","field","isVoid","forIn"],"mappings":"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"}