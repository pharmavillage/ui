function e(e){return e&&'object'==typeof e&&'default'in e?e.default:e}function t(e,t={immediate:1}){console.error('$watchAsStore is deprecated');let r=effector.createEvent(),o=effector.restore(r,{}),i=()=>{this.$watch(e,((e,t)=>{r({oldValue:t,newValue:e})}),t)};return this._data?i():this.$once('hook:created',i),o}function r(e){return console.error('$store is deprecated'),this.$watchAsStore(e).map((({newValue:e})=>e))}Object.defineProperty(exports,'__esModule',{value:1});var o=require('vue'),effector=require('effector'),i=e(o);const s={beforeCreate(){let e=this.$options.effector;if("function"==typeof e&&(e=e.call(this)),!e)return;this.$options.computed||(this.$options.computed={});let t={};if(effector.is.store(e))t={state:e};else{if('object'!=typeof e)throw Error('property should be Store');t={...e}}this.__clear=effector.createEvent(),effector.withRegion(this.__clear,(()=>{let e={},r=0;for(let o in t){let i=t[o];if(effector.is.store(i))e[o]=i;else{if(!effector.is.event(i)&&!effector.is.effect(i))throw Error(`Effector property ${o} should be Store or Unit (will be transform to Store<number>)`);e[o]=effector.restore(i.map((()=>++r)),null)}}let o=effector.combine(e);for(let e in o.defaultState)i.util.defineReactive(this,e,o.defaultState[e]);o.watch((e=>{for(let t in e)this[t]=e[t]}));for(let t in e){let r=effector.createEvent();effector.forward({from:r,to:e[t]}),this.$options.computed[t]={get:()=>this[t],set:r}}}))},beforeDestroy(){this.__clear&&effector.clearNode(this.__clear)}};exports.VueEffector=e=>{e.mixin(s),e.prototype.$watchAsStore=t,e.prototype.$store=r},exports.createComponent=(e,t)=>i.extend(Object.assign({},e,t&&{effector:()=>t}));
//# sourceMappingURL=effector-vue.cjs.js.map
