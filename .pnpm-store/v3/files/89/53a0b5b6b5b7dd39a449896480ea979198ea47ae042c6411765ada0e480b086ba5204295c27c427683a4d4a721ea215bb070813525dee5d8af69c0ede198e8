function t(t,e){return r.extend(Object.assign({},t,e&&{effector:()=>e}))}function e(t,e={immediate:1}){console.error('$watchAsStore is deprecated');let o=s(),r=l(o,{}),i=()=>{this.$watch(t,((t,e)=>{o({oldValue:e,newValue:t})}),e)};return this._data?i():this.$once('hook:created',i),r}function o(t){return console.error('$store is deprecated'),this.$watchAsStore(t).map((({newValue:t})=>t))}import r from'vue';import{is as i,createEvent as s,withRegion as f,restore as l,combine as n,forward as c,clearNode as a}from'effector/effector.mjs';let h=t=>{t.mixin(p),t.prototype.$watchAsStore=e,t.prototype.$store=o};const p={beforeCreate(){let t=this.$options.effector;if("function"==typeof t&&(t=t.call(this)),!t)return;this.$options.computed||(this.$options.computed={});let e={};if(i.store(t))e={state:t};else{if('object'!=typeof t)throw Error('property should be Store');e={...t}}this.__clear=s(),f(this.__clear,(()=>{let t={},o=0;for(let r in e){let s=e[r];if(i.store(s))t[r]=s;else{if(!i.event(s)&&!i.effect(s))throw Error(`Effector property ${r} should be Store or Unit (will be transform to Store<number>)`);t[r]=l(s.map((()=>++o)),null)}}let f=n(t);for(let t in f.defaultState)r.util.defineReactive(this,t,f.defaultState[t]);f.watch((t=>{for(let e in t)this[e]=t[e]}));for(let e in t){let o=s();c({from:o,to:t[e]}),this.$options.computed[e]={get:()=>this[e],set:o}}}))},beforeDestroy(){this.__clear&&a(this.__clear)}};export{h as VueEffector,t as createComponent};
//# sourceMappingURL=effector-vue.mjs.map
